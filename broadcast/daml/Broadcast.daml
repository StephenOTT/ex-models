-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Broadcast where

import DA.Action
import DA.Foldable (forA_)
import Daml.Script

data Something = Something with
  deriving (Eq, Show)

data BroadcastKey = BroadcastKey with
  broadcaster : Party
  id : Text
    deriving (Eq, Show)

template BroadcastData
  with
    broadcast : BroadcastKey
    payload : Something
  where
    signatory broadcast.broadcaster

    key broadcast : BroadcastKey
    maintainer key.broadcaster

template BroadcastSubscription
  with
    broadcast : BroadcastKey
    subscriber : Party
  where
    signatory broadcast.broadcaster
    observer subscriber
    key this : BroadcastSubscription
    maintainer key.broadcast.broadcaster

    nonconsuming choice UpdateData : (ContractId BroadcastData, BroadcastData)
      observer subscriber
      controller broadcast.broadcaster
      do
        fetchByKey @BroadcastData broadcast

    nonconsuming choice FetchData : BroadcastData
      with
        dataCid : ContractId BroadcastData
      controller subscriber
      do fetch dataCid

template Broadcast
  with
    broadcast : BroadcastKey
    subscribers : [Party]
  where
    signatory broadcast.broadcaster

    key broadcast : BroadcastKey
    maintainer key.broadcaster

    controller broadcast.broadcaster can
      nonconsuming BroadcastUpdate : ContractId BroadcastData
        with
          newPayload : Something
        do
          (oldDataCid, oldData) <- fetchByKey @BroadcastData (key this)
          archive oldDataCid
          let newData = oldData with payload = newPayload
          newDataCid <- create newData
          forA_ subscribers
            (\subscriber -> exerciseByKey @BroadcastSubscription (BroadcastSubscription with ..) UpdateData)
          return newDataCid

      AddSubscriber : (ContractId Broadcast, ContractId BroadcastSubscription)
        with
          subscriber : Party
        do
          bc <- create this with
            subscribers = subscriber :: subscribers
          bs <- create BroadcastSubscription with ..
          exercise bs UpdateData
          return (bc, bs)

test_broadcast = script do
  broadcaster <- allocateParty "Alice"
  subscribers <- mapA (allocateParty . (\i -> "Subscriber" <> show i)) [1..5]

  let
    broadcast = BroadcastKey with
      broadcaster
      id = "Broadcast"

  dataCid <- submit broadcaster do
    createCmd BroadcastData with
      broadcast
      payload = Something with

  bcCid <- submit broadcaster do
    createCmd Broadcast with
      broadcast
      subscribers = []

  let
    addSubscriber subscriber (bcCid : ContractId Broadcast) = do
      (newBcCid, _) <- submit broadcaster do
        exerciseCmd bcCid AddSubscriber with subscriber
      return newBcCid
    updateData (bcCid : ContractId Broadcast) = do
      submit broadcaster do
        exerciseCmd bcCid BroadcastUpdate with
          newPayload = Something with
    checkVis currentSubscribers dataCid = do
      forA_ subscribers (\subscriber ->
        let s = if subscriber `elem` currentSubscribers 
            then (\p e -> void (submit p e)) 
            else submitMustFail
         in s subscriber do
            exerciseByKeyCmd @BroadcastSubscription (BroadcastSubscription with ..)
              (FetchData with ..))
        
    checkAddAndUpdate (bcCid, dataCid, currentSubscribers) newSubscriber = do
      checkVis currentSubscribers dataCid
      newBcCid <- addSubscriber newSubscriber bcCid
      let newCurrentSubscribers = newSubscriber :: currentSubscribers
      checkVis newCurrentSubscribers dataCid
      newDataCid <- updateData newBcCid
      checkVis newCurrentSubscribers newDataCid
      return (newBcCid, newDataCid, newCurrentSubscribers)

  foldlA checkAddAndUpdate (bcCid, dataCid, []) subscribers
